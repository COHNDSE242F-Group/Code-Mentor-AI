{
    "batch_id" : 1,
    "concepts" : [ {
        "id" : 1,
        "name" : "Data Structures",
        "description" : "Understanding various data structures like arrays, linked lists, stacks, queues, trees, and graphs.",
        "prerequisites" : [ ],
        "related_concepts" : [ 2, 3 ],
        "topics" : [
            { "id": 1, "name": "Introduction to Data Structures" },
            { "id": 2, "name": "Arrays" },
            { "id": 3, "name": "Dynamic Arrays / ArrayList" },
            { "id": 4, "name": "Strings as Arrays" },
            { "id": 5, "name": "Two-Dimensional Arrays / Matrices" },
            { "id": 6, "name": "Linked Lists" },
            { "id": 7, "name": "Singly Linked List" },
            { "id": 8, "name": "Doubly Linked List" },
            { "id": 9, "name": "Circular Linked List" },
            { "id": 10, "name": "Stack (LIFO)" },
            { "id": 11, "name": "Stack Implementation Using Arrays" },
            { "id": 12, "name": "Stack Implementation Using Linked List" },
            { "id": 13, "name": "Queue (FIFO)" },
            { "id": 14, "name": "Queue Implementation Using Arrays" },
            { "id": 15, "name": "Queue Implementation Using Linked List" },
            { "id": 16, "name": "Circular Queue" },
            { "id": 17, "name": "Priority Queue" },
            { "id": 18, "name": "Deque (Double-Ended Queue)" },
            { "id": 19, "name": "Hash Table / Hash Map" },
            { "id": 20, "name": "Hash Functions" },
            { "id": 21, "name": "Collision Resolution Techniques" },
            { "id": 22, "name": "Open Addressing / Linear Probing" },
            { "id": 23, "name": "Separate Chaining" },
            { "id": 24, "name": "Trees" },
            { "id": 25, "name": "Binary Trees" },
            { "id": 26, "name": "Binary Search Tree (BST)" },
            { "id": 27, "name": "Tree Traversals (Inorder, Preorder, Postorder)" },
            { "id": 28, "name": "Balanced Trees (AVL Trees)" },
            { "id": 29, "name": "Red-Black Trees" },
            { "id": 30, "name": "Segment Trees" },
            { "id": 31, "name": "Fenwick / Binary Indexed Trees" },
            { "id": 32, "name": "Heaps" },
            { "id": 33, "name": "Min Heap / Max Heap" },
            { "id": 34, "name": "Heap Implementation Using Arrays" },
            { "id": 35, "name": "Heap Sort" },
            { "id": 36, "name": "Graphs" },
            { "id": 37, "name": "Graph Representation (Adjacency Matrix / List)" },
            { "id": 38, "name": "Directed vs Undirected Graphs" },
            { "id": 39, "name": "Weighted vs Unweighted Graphs" },
            { "id": 40, "name": "Graph Traversals (BFS / DFS)" },
            { "id": 41, "name": "Topological Sorting" },
            { "id": 42, "name": "Shortest Path Algorithms (Dijkstra, Bellman-Ford)" },
            { "id": 43, "name": "Minimum Spanning Tree (Prim, Kruskal)" },
            { "id": 44, "name": "Union-Find / Disjoint Set" },
            { "id": 45, "name": "Trie (Prefix Tree)" },
            { "id": 46, "name": "Suffix Tree / Suffix Array" },
            { "id": 47, "name": "Bloom Filter" },
            { "id": 48, "name": "Graph Coloring / Applications" },
            { "id": 49, "name": "Advanced Linked Structures (Skip List)" },
            { "id": 50, "name": "Amortized Analysis of Data Structures" },
            { "id": 51, "name": "Dynamic Programming with Data Structures" },
            { "id": 52, "name": "Applications of Data Structures" }
        ]
    }, {
        "id" : 2,
        "name" : "Control Structures",
        "description" : "Learning about conditional statements and loops to control the flow of a program.",
        "prerequisites" : [ 1 ],
        "related_concepts" : [ 1, 4 ],
        "topics" :[{ "id": 1, "name": "Simple If" },
            { "id": 2, "name": "If-Else" },
            { "id": 3, "name": "Else-If / Nested If" },
            { "id": 4, "name": "Ternary Operator / Conditional Expression" },
            { "id": 5, "name": "Switch / Case"},
            { "id": 6, "name": "Switch with Default"},
            { "id": 7, "name": "For Loop"},
            { "id": 8, "name": "For Loop with Break"},
            { "id": 9, "name": "For Loop with Continue"},
            { "id": 10, "name": "Nested For Loops"},
            { "id": 11, "name": "While Loop"},
            { "id": 12, "name": "While Loop with Break"},
            { "id": 13, "name": "While Loop with Continue"},
            { "id": 14, "name": "Nested While Loops"},
            { "id": 15, "name": "Do-While Loop"},
            { "id": 16, "name": "Do-While Loop with Break" },
            { "id": 17, "name": "Do-While Loop with Continue" },
            { "id": 18, "name": "Nested Do-While Loops" },
            { "id": 19, "name": "Enhanced For / For-Each Loop" },
            { "id": 20, "name": "Break Statement" },
            { "id": 21, "name": "Continue Statement" },
            { "id": 22, "name": "Return Statement" },
            { "id": 23, "name": "Goto / Labels (if applicable)" },
            { "id": 24, "name": "Try-Catch" },
            { "id": 25, "name": "Catch Multiple Exceptions" },
            { "id": 26, "name": "Finally / Cleanup" },
            { "id": 27, "name": "Throw / Raise Exceptions" },
            { "id": 28, "name": "Nested Try-Catch" },
            { "id": 29, "name": "Conditional Breaks inside Loops" },
            { "id": 30, "name": "Conditional Continues inside Loops" },
            { "id": 31, "name": "Infinite Loop (for/while/do-while)" },
            { "id": 32, "name": "Loop with Logical Operators in Condition" },
            { "id": 33, "name": "Short-Circuit Evaluation in Conditions" } ]
    }, {
        "id" : 3,
        "name" : "Functions",
        "description" : "Defining and invoking functions to organize code into reusable blocks.",
        "prerequisites" : [ 1 ],
        "related_concepts" : [ 1, 4 ],
        "topics" : [
            { "id": 1, "name": "Introduction to Functions" },
            { "id": 2, "name": "Function Definition and Syntax" },
            { "id": 3, "name": "Function Parameters and Arguments" },
            { "id": 4, "name": "Positional Arguments" },
            { "id": 5, "name": "Keyword Arguments" },
            { "id": 6, "name": "Default Arguments" },
            { "id": 7, "name": "Variable-Length Arguments (*args, **kwargs)" },
            { "id": 8, "name": "Return Values" },
            { "id": 9, "name": "Multiple Return Values" },
            { "id": 10, "name": "Scope and Lifetime of Variables" },
            { "id": 11, "name": "Local vs Global Variables" },
            { "id": 12, "name": "Nested Functions / Inner Functions" },
            { "id": 13, "name": "Recursive Functions" },
            { "id": 14, "name": "Lambda / Anonymous Functions" },
            { "id": 15, "name": "First-Class Functions" },
            { "id": 16, "name": "Passing Functions as Arguments" },
            { "id": 17, "name": "Returning Functions from Functions" },
            { "id": 18, "name": "Closures" },
            { "id": 19, "name": "Decorators" },
            { "id": 20, "name": "Higher-Order Functions" },
            { "id": 21, "name": "Function Annotations / Type Hints" },
            { "id": 22, "name": "Built-in Functions" },
            { "id": 23, "name": "User-Defined Functions" },
            { "id": 24, "name": "Function Documentation (docstrings)" },
            { "id": 25, "name": "Partial Functions / functools.partial" },
            { "id": 26, "name": "Function Overloading (where applicable)" },
            { "id": 27, "name": "Anonymous Functions in Functional Programming" },
            { "id": 28, "name": "Recursion vs Iteration" },
            { "id": 29, "name": "Function Optimization Techniques" },
            { "id": 30, "name": "Error Handling in Functions (try/except inside functions)" },
            { "id": 31, "name": "Function Testing / Unit Testing" },
            { "id": 32, "name": "Function Application in Real Programs" }
        ]
    }, {
        "id" : 4,
        "name" : "Object-Oriented Programming",
        "description" : "Understanding classes, objects, inheritance, and encapsulation.",
        "prerequisites" : [ 2, 3 ],
        "related_concepts" : [ 2, 3 ],
        "topics" : [
            { "id": 1, "name": "Introduction to OOP" },
            { "id": 2, "name": "Classes and Objects" },
            { "id": 3, "name": "Attributes / Properties / Fields" },
            { "id": 4, "name": "Methods / Functions in Classes" },
            { "id": 5, "name": "Constructors / __init__ Method" },
            { "id": 6, "name": "Destructors / __del__ Method" },
            { "id": 7, "name": "Encapsulation" },
            { "id": 8, "name": "Private, Protected, Public Members" },
            { "id": 9, "name": "Getter and Setter Methods / Properties" },
            { "id": 10, "name": "Inheritance" },
            { "id": 11, "name": "Single Inheritance" },
            { "id": 12, "name": "Multiple Inheritance" },
            { "id": 13, "name": "Multilevel Inheritance" },
            { "id": 14, "name": "Hierarchical Inheritance" },
            { "id": 15, "name": "Hybrid Inheritance" },
            { "id": 16, "name": "Polymorphism" },
            { "id": 17, "name": "Method Overriding" },
            { "id": 18, "name": "Operator Overloading" },
            { "id": 19, "name": "Abstract Classes and Methods" },
            { "id": 20, "name": "Interfaces (or Protocols / Abstract Base Classes)" },
            { "id": 21, "name": "Composition / Aggregation" },
            { "id": 22, "name": "Association" },
            { "id": 23, "name": "Class Variables vs Instance Variables" },
            { "id": 24, "name": "Static Methods" },
            { "id": 25, "name": "Class Methods" },
            { "id": 26, "name": "Magic / Dunder Methods" },
            { "id": 27, "name": "Object Identity and Equality" },
            { "id": 28, "name": "Method Resolution Order (MRO)" },
            { "id": 29, "name": "Exception Handling in Classes" },
            { "id": 30, "name": "Design Principles: SOLID" },
            { "id": 31, "name": "Encapsulation and Data Hiding" },
            { "id": 32, "name": "OOP Best Practices" },
            { "id": 33, "name": "Real-World Applications of OOP" }
        ]
    } ]
}